## Mission 2: 비관적 락(Pessimistic) & 낙관적 락(Optimistic)

### 📝 개요

Mission 1에서 우리는 100명 한정 선착순 이벤트에 다수의 트랜잭션이 동시에 접근할 때 발생하는 **초과 판매(Overselling)**와 **Lost Update** 문제를 눈으로 확인했습니다. 애플리케이션 레벨의 제어(`synchronized`)는 다중 서버 환경에서 무용지물이므로, 이제 **데이터베이스가 제공하는 락(Lock)**을 활용하여 이 문제를 완벽하게 통제해 봅니다.

### 🎯 주요 학습 목표

1. **비관적 락(Pessimistic Lock)**을 적용하여 데이터 정합성을 강제로 보장하는 방법을 학습합니다.
2. **낙관적 락(Optimistic Lock)**을 적용하고, 충돌 발생 시 애플리케이션 단에서 재시도(Retry)하는 로직을 구현합니다.
3. 선착순 이벤트처럼 **'데이터 충돌(Collision)이 극심한 환경'**에서 두 락의 성능과 장단점(Trade-off)을 비교 분석합니다.

---

## 🛠️ 요구사항

### 1. 비관적 락(Pessimistic Lock) 구현 및 검증

* **상황:** "이 데이터는 무조건 누군가 동시에 수정할 거야!"라고 비관적으로 가정하고, 읽는 시점부터 락을 겁니다.
* **작업 내용:**
1. `EventRepository`에 비관적 락을 사용하는 조회 메서드를 추가하세요. (힌트: `@Lock(LockModeType.PESSIMISTIC_WRITE)`)
2. 비관적 락을 사용하는 서비스 로직(`participateWithPessimisticLock`)을 구현하세요.
3. **테스트 코드:** 1,000명의 사용자가 동시에 접근했을 때, 정확히 100명만 성공하고 900명은 실패(혹은 대기 후 정원 초과 예외)하는지 검증하세요.

### 2. 낙관적 락(Optimistic Lock) 구현 및 재시도 로직

* **상황:** "동시에 수정할 일이 별로 없을 거야~"라고 낙관적으로 가정하고, 일단 수정한 뒤 커밋 시점에 버전(Version)을 확인해 충돌을 감지합니다.
* **작업 내용:**
1. 기존 `Event` 엔티티에 낙관적 락을 위한 필드를 추가하세요. (힌트: `@Version`)
2. `EventRepository`에 낙관적 락을 사용하는 조회 메서드를 추가하세요. (힌트: `@Lock(LockModeType.OPTIMISTIC)`)
3. 낙관적 락을 사용하는 서비스 로직(`participateWithOptimisticLock`)을 구현하세요.
4. **핵심:** 낙관적 락은 충돌 시 `ObjectOptimisticLockingFailureException`을 발생시킵니다. 이 예외를 잡아서 **재시도(Retry)하는 파사드(Facade) 로직**을 별도로 구현해야 합니다.
5. **테스트 코드:** 비관적 락과 동일하게 1,000명의 요청을 보내고 정확히 100명이 성공하는지 검증하세요.

---

### 고민해 볼 점

1. **성능 비교:** 1,000개의 동시 요청을 처리할 때, 비관적 락과 낙관적 락 중 어느 쪽의 테스트 실행 속도가 더 빨랐나요? 그 이유는 무엇일까요?
2. **선착순 이벤트에 적합한 락은?:** 현재 우리가 구현하는 '선착순 100명 이벤트' 상황에서는 낙관적 락과 비관적 락 중 어떤 방식이 더 적절할까요? (힌트: 충돌 확률이 높은가요, 낮은가요?)
3. **낙관적 락의 단점:** 트래픽이 엄청나게 몰릴 때, 낙관적 락의 재시도(Retry) 로직은 서버와 DB에 어떤 영향을 미칠까요?

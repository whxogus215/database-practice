# 🚀 프로젝트: "선착순 이벤트 참여 시스템"

## 프로젝트 개요
당신은 인기 있는 온라인 서비스의 백엔드 개발자입니다.  
이번에 마케팅 팀에서 **선착순 100명 한정 이벤트**를 기획했습니다.  
사용자들이 동시에 이벤트 참여 버튼을 눌렀을 때, 정확히 100명만 참여에 성공해야 하며,  
**동시성 문제로 인해 정원을 초과하거나 데이터 불일치가 발생해서는 안 됩니다.**

이 프로젝트에서는 데이터베이스 락(Lock)을 활용하여 동시성 문제를 해결하는 과정을 다룹니다.

## 주요 학습 목표
- **Race Condition 경험**: 여러 스레드가 동시에 공유 자원(이벤트 참여 인원)에 접근할 때 발생하는 데이터 불일치 문제를 경험합니다.
- **Lost Update 문제**: 두 트랜잭션이 동시에 같은 데이터를 수정할 때, 하나의 수정사항이 덮어씌워지는 현상을 확인합니다.
- **Lock의 필요성 체감**: 트랜잭션 격리 수준만으로는 해결되지 않는 동시성 문제를 해결하기 위해, 비관적 락(Pessimistic Lock)과 낙관적 락(Optimistic Lock) 등의 기법을 적용해 봅니다.

---

## Mission 1: 선착순 이벤트 참여 중 발생하는 동시성 문제

### 상황
이벤트 오픈 시각인 12:00:00, 수백 명의 사용자가 동시에 '참여하기' 버튼을 클릭합니다.
- 하나의 트랜잭션 = '이벤트 참여 요청'
  1. **(조회)**: 현재 이벤트의 참여 인원 수를 조회합니다.
  2. **(검증)**: 현재 인원이 최대 인원(100명)보다 적은지 확인합니다.
  3. **(갱신)**: 현재 인원을 +1 증가시키고 저장합니다.
  4. **(참여 기록)**: 참여자 목록 테이블에 사용자를 추가합니다.

- 동시 접근 발생
  1. 사용자 A와 사용자 B가 동시에 현재 인원을 조회합니다. (둘 다 99명으로 조회)
  2. 둘 다 "아직 자리가 있네?"라고 판단하고 인원을 +1 증가시킵니다.
  3. 결과적으로 두 명이 참여했지만, 카운트는 100명으로 1만 증가하는 **Lost Update**가 발생합니다.
  4. 심지어 100명이 꽉 찬 상태에서도 여러 명이 동시에 통과하여 105명, 110명이 참여하는 초과 사태가 발생할 수 있습니다.

### 요구사항
1. `Event`와 관련된 엔티티를 생성하고, 실제 이벤트에 참여하는 로직을 구현하세요.
2. 데드락이 발생하는지 테스트 코드로 검증하고, 데드락이 발생했다면, 근거를 찾고 분석하세요.
3. 분석한 결과를 바탕으로 이 문제를 해결하고, 과정을 정리하세요.

### 고민해 볼 점
- 트랜잭션의 격리 수준(Isolation Level)을 높이면 이 문제가 해결될까요?
- 데이터베이스의 락(Lock) 없이 애플리케이션 레벨(Java `synchronized` 등)에서 해결할 때의 문제점은 무엇일까요? (다중 서버 환경 고려)

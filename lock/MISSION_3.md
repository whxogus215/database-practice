# 🚀 Mission 3: 네임드 락(Named Lock)을 활용한 동시성 제어

## 📝 개요

데이터베이스의 레코드(Row) 자체가 아니라, 메타데이터(문자열)에 락을 거는 네임드 락을 활용해 선착순 이벤트를 제어합니다. 레코드 락으로 인한 데드락(Deadlock) 위험을 회피하고, 별도의 락 매니저 역할을 DB에게 맡겨봅니다.

## 🎯 주요 학습 목표

1. MySQL의 내장 함수인 `GET_LOCK()`과 `RELEASE_LOCK()`의 동작 원리를 이해합니다.
2. 락을 획득하고 해제하는 로직과, 실제 비즈니스 로직(참여 처리)의 **트랜잭션 범위를 분리**하는 파사드(Facade) 패턴을 설계합니다.
3. 커넥션 풀(Connection Pool) 고갈이라는 네임드 락의 치명적인 부작용(Side-effect)을 인지하고 해결책을 고민합니다.

---

## 🛠️ 요구사항

### 1. MySQL의 락 함수 호출

* JpaRepository를 활용해 Native Query로 MySQL의 락 함수를 호출해야 합니다.
* 락 획득: `SELECT GET_LOCK(:key, :timeoutSeconds)`
* 락 해제: `SELECT RELEASE_LOCK(:key)`

### 2. 네임드 락 파사드(Facade) 클래스 구현

* 비즈니스 로직을 감싸는 `NamedLockEventFacade`를 생성하세요.
* 동작 순서는 반드시 다음과 같아야 합니다.
  1. 락 획득 (이벤트 ID 등을 Key로 사용)
  2. 비즈니스 로직 실행 (기존에 만든 `참여(participate)` 메서드 호출)
  3. 락 해제 (반드시 `finally` 블록에서 실행하여 에러가 나도 락이 풀리도록 보장)

### 3. 트랜잭션 분리

* 부모(Facade)의 트랜잭션과 자식(비즈니스 로직)의 트랜잭션이 **분리**되어야 합니다.
* 비즈니스 로직이 커밋되어 DB에 데이터가 완전히 반영된 **이후에** 락이 해제되어야 안전합니다. (Spring의 `@Transactional(propagation = Propagation.REQUIRES_NEW)` 활용)

### 4. 테스트 코드 검증

* 이전 미션과 동일하게 150명의 동시 요청을 보내고 정확히 100명이 성공하는지 검증하세요.

---

## 🤔 고민해 볼 점

1. **커넥션 풀 고갈 문제:** 네임드 락을 사용할 때, 기본 HikariCP 커넥션 풀 사이즈(보통 10개)를 그대로 쓰면 1,000명 동시 요청 시 **커넥션 타임아웃(Connection is not available)** 에러가 발생할 확률이 높습니다. 원인이 무엇이고, 락 전용 데이터소스(DataSource)를 분리해야 하는 이유는 무엇일까요?
2. **비관적 락 vs 네임드 락:** 비관적 락과 네임드 락 모두 DB를 사용합니다. 그렇다면 **어떤 상황에서 비관적 락 대신 네임드 락을 선택**하는 것이 현명할까요?

# 🚀 프로젝트: "공안 대마 특이 4과 임무 관리 시스템"
## 프로젝트 개요
당신은 '마키마'의 지시를 받아, 데블 헌터들의 임무 수행 실적을 관리하는 백엔드 시스템을 개발합니다.  
헌터들이 토벌한 악마에서 수집한 **총의 악마 살점을 집계**하고, 그들의 공안 내 등급을 관리하며,  
특정 구역에 출몰한 악마를 리포트하는 과정에서 발생하는 **데이터 동시성 문제를 오직 트랜잭션 격리 수준만으로 제어**해 봅니다.

## 주요 학습 목표
- **Dirty Read 경험**: 한 트랜잭션이 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽을 때 발생하는 문제를 경험합니다.
- **Non-Repeatable Read 경험**: 한 트랜잭션 내에서 같은 데이터를 두 번 읽었을 때 다른 결과가 나오는 현상을 경험합니다.
- **Phantom Read 경험**: 한 트랜잭션 내에서 같은 범위로 쿼리를 두 번 실행했을 때, 없던 데이터가 나타나는 현상을 경험합니다.
- **격리 수준의 효과 체감**: `READ_UNCOMMITTED`부터 `SERIALIZABLE`까지 스프링 `@Transactional(isolation = ...)` 설정을 변경하며 각 문제가 어떻게 해결되거나 다르게 동작하는지 코드로 직접 확인합니다.

---
## Mission 1: '덴지와 파워'의 임무 정산 중 발생하는 Dirty Read

### 상황
'덴지'와 '파워'가 한 팀이 되어 악마 토벌 임무를 마쳤습니다. 이제 본부에서 임무 결과를 정산하는 트랜잭션이 시작됩니다.
- 하나의 트랜잭션 = '임무 번호 123 정산'
  1. **(데이터 증가)**: '덴지'가 수집한 악마의 살점 5개를 총량에 더합니다. (아직 커밋 전)
  2. **(데이터 감소)**: '파워'가 임무 중 분실한 살점 2개에 대한 책임을 물어 총량에서 차감합니다. (아직 커밋 전)
- 동시 접근 발생
  1. 위의 정산 트랜잭션(1번과 2번)이 모두 끝나고 **커밋(Commit)되기 전**, 별개의 트랜잭션('마키마의 실시간 현황판')이 현재까지 수집된 살점의 총합을 조회합니다.

### 요구사항
1. `DevilFlesh` 엔티티 생성
   - `id`, `totalPieces` (수집된 살점 총량)
2. `MissionReportService` 구현
   - 하나의 메서드(`settleMission`) 안에서 `totalPieces`를 증가시키고, 또 감소시키는 로직을 구현합니다.
   - 이 메서드 전체가 하나의 트랜잭션으로 묶여야 합니다.
3. 테스트 코드 작성
   - `settleMission` 메서드가 실행되는 도중(커밋 전), 별도의 스레드가 살점 총량을 조회하도록 하여 **Dirty Read**를 재현합니다.
   - `@Transactional(isolation = Isolation.READ_UNCOMMITTED)`를 사용하여 현상을 관찰합니다.

### 고민해 볼 점
- 만약 정산 트랜잭션이 중간에 롤백(Rollback)된다면, 마키마의 현황판이 읽어간 데이터는 어떻게 될까요? 이것이 왜 치명적인 문제일까요?
---
## 🚀 Mission 2: '반복 불가능한 읽기(Non-Repeatable Read)' 문제 해결

### 상황
공안 대마 특이 4과의 데이터 분석관(트랜잭션 A)이 '하야카와 아키' 헌터의 실적 보고서를 작성하기 시작했습니다.

1. [분석관]이 보고서 작성을 위해 트랜잭션을 시작하고, 아키의 현재 등급('Middling')을 조회합니다.
2. [분석관]이 보고서의 다른 부분을 작성하는 사이, 별도 시스템(트랜잭션 B) 에서 아키의 최근 임무 성공을
   반영하여 등급을 **Exceptional**로 갱신하고 즉시 커밋(Commit)합니다.
3. [분석관]이 보고서 제출 전 최종 확인을 위해, 자신의 트랜잭션 내에서 아키의 등급을 다시 조회합니다.

이때, 처음 조회했던 등급과 두 번째 조회한 등급이 달라 데이터 불일치가 발생하는 '반복 불가능한 읽기' 현상을 경험하게 됩니다.

### 요구사항
1. `DevilHunter` 엔티티 생성
   - `id` (헌터 ID)
   - `name` (헌터 이름, e.g., "Aki Hayakawa")
   - `rank` (헌터 등급, e.g., "Middling", "Exceptional")

2. '등급 조회' 및 '등급 갱신' 서비스 로직 구현
   - `HunterProfileService`: 특정 헌터의 정보를 조회하는 비즈니스 로직. 이 서비스의 핵심은, 하나의 메서드(getHunterRankInTransaction) 안에서 등급을 두 번 조회하고 그 사이에는 Thread.sleep으로 약간의 시간차를 둡니다.
   - `HunterAdminService`: 특정 헌터의 등급을 갱신하는 비즈니스 로직.

3. 테스트 코드 작성
   - `READ_COMMITTED` 격리 수준에서 위 상황을 재현하여, 한 트랜잭션 내의 두 SELECT 결과가 다르게 나오는 Non-Repeatable Read 현상을 직접 확인합니다.
   - 이후, 격리 수준을 `REPEATABLE_READ` 로 변경하여 동일한 테스트를 실행했을 때, 두 SELECT 결과가 동일하게 유지되어 문제가 해결되는 것을 확인합니다.

### 고민해 볼 점
- `READ_COMMITTED`는 왜 다른 트랜잭션이 커밋한 변경사항을 즉시 볼 수 있을까요?
- `REPEATABLE_READ`는 어떤 원리로 한 트랜잭션 내에서 데이터의 일관성을 보장해 줄까요? (Mission 1의 MVCC 개념을 다시 떠올려 보세요.)

## 🚀 Mission 1: 읽기/쓰기 부하 분산을 위한 레플리케이션(Replication) 도입

### 상황
'체인소맨 팬덤 플랫폼'이 폭발적인 인기를 끌며 전 세계 수백만 사용자가 활동하고 있습니다. 모든 사용자 활동 기록(user_activity_logs)이 단 하나의 데이터베이스 서버에 쌓이고 있습니다.

이로 인해 두 가지 심각한 문제가 동시에 발생하고 있습니다.

1. 쓰기(Write) 부하: 사용자들이 실시간으로 남기는 게시글, 댓글, 좋아요 등의 INSERT 작업이 많아지면서 데이터베이스에 부담을 주고 있습니다. 이로 인해 가끔씩 사용자들이 "댓글이 느리게 달려요"와 같은 불편을 겪기 시작했습니다.

2. 읽기(Read) 부하: 데이터 분석팀은 사용자 활동 패턴을 분석하기 위해 복잡하고 무거운 SELECT 쿼리(e.g., "오늘 가장 '좋아요'를 많이 받은 게시글 TOP 100")를 수시로 실행합니다. 이 쿼리가 실행될 때마다 데이터베이스 CPU 사용량이 치솟아, 실시간 INSERT 작업에까지 영향을 미칩니다.

결정적으로, 이 단일 데이터베이스는 **단일 장애점(Single Point of Failure, SPOF)**입니다. 점검이나 장애로 서버가 다운되면 플랫폼 전체가 멈춰버립니다.

### 요구사항
당신은 이 문제를 해결하기 위한 첫 번째 단계로 데이터베이스 레플리케이션(Replication) 도입을 결정했습니다. 아래 항목에 맞춰 당신의 설계안을 '논리적 설명'과 '아키텍처 다이어그램'으로 제시해 주세요.

1. 문제 분석 및 해결 방안
   - 현재 시스템의 가장 큰 문제점은 무엇이며, 왜 단일 데이터베이스 구조로는 더 이상 감당할 수 없는지 설명해 주세요.
   - 이 문제를 해결하기 위해 레플리케이션(Replication) 구조가 왜 가장 적합한 첫 번째 해결책인지 그 이유를 설명해 주세요.

2. 아키텍처 설계 (Before & After)
   - Primary (Source) DB와 Replica DB의 역할을 명확히 정의해 주세요.
   - 레플리케이션을 도입하기 전(Before)과 후(After)의 시스템 아키텍처를 다이어그램으로 그려서 설명해 주세요.
     - (예시: 쓰기 요청과 읽기 요청의 흐름이 어떻게 달라지는지 화살표로 표시)

3. 쿼리 라우팅(Routing) 전략
   - 애플리케이션 서버는 어떤 쿼리를 Primary DB로 보내고, 어떤 쿼리를 Replica DB로 보내야 할까요? 그 라우팅 규칙을 구체적으로 설명해 주세요. (e.g., INSERT, UPDATE, DELETE는 어디로? SELECT는 어디로?)

4. 고민해 볼 점 (Trade-offs)
   - 만약 Primary DB의 변경사항이 Replica DB에 아직 반영되지 않은 상태(Replication Lag)에서 사용자가 데이터를 조회하면 어떤 문제가 발생할 수 있을까요? (e.g., 방금 쓴 내 댓글이 보이지 않는 현상)
   - Primary DB에 장애가 발생했을 때, 어떻게 서비스를 계속 유지할 수 있을까요? (Failover 전략)

## 답변

### 1. 문제 분석 및 해결 방안
- 읽기와 쓰기 부하가 하나의 DB에 몰리고 있기에 두 가지 상황이 발생할 수 있습니다.
  1) 사용자 쓰기 부하가 몰리는 상황에서 특정 유저의 요청이 제대로 처리되지 않을 수 있으며, 데이터베이스 장애 발생 시, 백업 수단이 없어서 사용자의 모든 데이터가 유실될 수 있습니다.
  2) 데이터 분석팀의 읽기 부하로 인해 사용자들의 쓰기 부하가 제대로 처리되지 않을 수 있으며, 이는 사용자 이탈로 이어질 수 있습니다.
  

- 레플리케이션은 위와 같은 상황에서 적합한 해결책이 될 수 있습니다.
  1) 읽기 부하와 쓰기 부하를 각각 전담하는 두 개 이상의 복제본 DB를 두어 부하를 분산시키면, **사용자의 쓰기 요청과 데이터 분석팀의 읽기 요청을 물리적으로 분산시켜 처리할 수 있습니다.**
  2) **대부분의 플랫폼은 쓰기 부하보다 읽기 부하가 더 많기 때문에 읽기 부하를 담당하는 DB를 더 추가**하면, 대부분 사용자의 사용률 저하를 막을 수 있습니다.
  3) 쓰기 부하 DB의 장애가 발생하더라도 다른 복제 DB가 승격함으로써 **가용성을 높이고, 복제 DB로부터 백업을 안전하게 처리할 수 있습니다.**

### 2. 아키텍처 설계
- 소스 DB : **모든 쓰기 연산을 담당**하며, 트래픽 상황에 따라 읽기 연산도 처리할 수 있습니다.
- 레플리카 DB : **모든 읽기 연산을 담당**하며, 레플리카 DB가 두 개 이상일 경우, 나머지 한 개는 백업 DB로 존재합니다. 이는 장애 발생 시, 복구 용도로 활용됩니다. 또한, 데이터 분석팀의 분석 쿼리 혹은 배치 작업 등에 레플리카 DB가 활용됩니다.
  
 <img alt="img.png" height="300" src="1-replication.png" width="500"/>
 
### 3. 쿼리 라우팅 전략
- SELECT를 제외한 쿼리는 Source DB로 전송합니다. SELECT 쿼리는 Replica DB로 전송합니다.

### 4. 고민해볼 점
- MySQL의 경우, **반동기 복제 과정에서 Source DB에 커밋되기 전에 Replica DB에 바이너리 변경사항을 전달해 복제를 수행(AFTER_SYNC)**함으로써 팬텀 리드 현상을 방지하는 시스템 설정을 할 수 있습니다. 이러한 DB의 아키텍처에 따라 일관성과 실시간성 사이에서의 간극을 줄이는 노력이 필요합니다.
- Source DB에 장애가 발생하면, 대기 중인 백업 DB를 새로운 Source DB로 승격시킵니다.

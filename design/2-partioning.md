## 🚀 Mission 2: 거대 테이블 분할을 위한 파티셔닝(Partitioning) 도입

### 상황
레플리케이션을 도입한 지 1년이 지났습니다. 시스템은 안정화되었지만, 새로운 문제가 발생했습니다.

`user_activity_logs` 테이블이 **단일 테이블임에도 불구하고 수십억 건의 데이터를 기록**하며 거대해졌습니다.

레플리케이션을 통해 읽기 전용 DB(Replica DB)를 분리했지만, 데이터 분석팀의 불만이 폭주하고 있습니다.

- **분석팀의 불만**: "Replica DB를 조회하는데도 쿼리가 너무 느려요! 특히 월별/분기별 리포트를 뽑으려고 `created_at` 컬럼으로 `WHERE`절을 거는 순간, 쿼리가 몇 시간씩 걸리거나 타임아웃이 납니다."
- **운영팀의 불만**: "오래된 로그 데이터(예: 2년 전 데이터)를 삭제하려고 `DELETE` 쿼리를 실행하면, DB에 엄청난 락(Lock)이 걸려서 전체 서비스가 느려집니다. 데이터를 지우는 것조차 공포스럽습니다."

`user_activity_logs` 테이블이 너무 커서, 인덱스를 타는 쿼리조차 느려지고 데이터 관리가 불가능한 지경에 이르렀습니다. 이 문제를 해결하기 위해 당신은 파티셔닝(Partitioning) 도입을 결정합니다.

### 요구사항
이 문제를 해결하기 위한 파티셔닝 설계안을 '논리적 설명'과 '아키텍처 다이어그램'으로 제시해 주세요.

1. **문제 분석 및 해결 방안**
   - 레플리케이션을 도입했음에도 불구하고 왜 `SELECT`와 `DELETE`가 느린지, 그 근본 원인을 설명해 주세요.
   - 이 문제를 해결하는 데 왜 **파티셔닝**이 적합한 해결책인지 그 이유를 설명해 주세요. (샤딩과 어떻게 다른가요?)

2. **아키텍처 설계 (논리적)**
   - `user_activity_logs` 테이블을 파티셔닝할 구체적인 전략을 설계해 주세요.
     - **파티션 키(Partition Key)**: 어떤 컬럼을 기준으로 테이블을 나눌 것인가요?
     - **파티션 타입(Partition Type)**: 어떤 파티셔닝 방식을 사용할 것인가요? (e.g., `RANGE`, `LIST`, `HASH`)
     - **파티션 관리**: 월별로 나눌 것인지, 일별로 나눌 것인지 구체적인 관리 계획을 제시해 주세요.

3. **파티셔닝의 효과 (Query & Maintenance)**
   - 파티셔닝을 적용하면 왜 데이터 분석팀의 '월별 리포트' 쿼리가 빨라지는지 그 원리를 설명해 주세요. **(Partition Pruning)**
   - 파티셔닝이 어떻게 운영팀의 '오래된 데이터 삭제' 문제를 해결해 주는지 설명해 주세요. (e.g., `DROP PARTITION`)

4. **고민해 볼 점 (Trade-offs)**
   - 만약 파티션 키를 잘못 선정하면 (e.g., `user_id`를 `HASH`로 파티셔닝) '월별 리포트' 쿼리에 어떤 문제가 발생할까요?
   - 파티셔닝은 단일 DB 서버 내에서의 작업입니다. 만약 파티셔닝으로도 감당이 안 될 만큼 쓰기(Write) 자체가 많아지면, 그때는 무엇을 고려해야 할까요? (Mission 3의 예고입니다.)
---
## 답변

### 1. **문제 분석 및 해결 방안**
- 레플리케이션은 DB 서버를 물리적으로 복제하기 때문에 DB 내에 존재하는 테이블까지 전부 똑같이 복제하고 있습니다. 따라서 DB 요청을 쿼리 타입에 따라 분리 시키더라도 **테이블에 저장된 레코드 개수가 많으면, 단일 DB 내에서 조회 속도는 느려질 수 밖에 없습니다.**
- 단일 테이블 내에 데이터의 규모가 수십억건이 된다면, 이 때는 DB가 아닌 테이블을 물리적으로 분리시키는 **파티셔닝**을 적용함으로써 테이블의 조회 혹은 삭제 속도를 향상시킬 수 있습니다.

### 2. **아키텍처 설계 (논리적)**
- 파티션 키는 `user_activity_logs`의 `created_at` 컬럼을 파티션 키로 지정합니다. 로그 데이터이므로 날짜를 기준으로 파티션을 하기 위해 생성 날짜를 기준으로 파티션을 구분합니다.
  - 다만, 해당 테이블의 모든 유니크 인덱스에는 `created_at` 컬럼을 포함해야 합니다.
- 파티션 타입은 `RANGE` 타입입니다. 생성 날짜는 연속된 값으로 년도 혹은 월을 기준으로 구분할 수 있으므로 이에 적합한 범위 기반의 파티셔닝을 진행합니다.
- 파티션은 **월**별로 나눕니다. (ex. `p_2025_03`, `p_2025_07`)

### 3. **파티셔닝의 효과 (Query & Maintenance)**
- 분석팀은 월별/분기별 리포트를 뽑기 위해 단일 년도에 대한 파티션만 조회하여 목적에 관계없는 레코드 조회를 걸러낼 수 있습니다. (파티션 프루닝)
- 운영팀은 오래된 로그 데이터를 파티션 기준으로 삭제할 수 있습니다. 별도의 레코드에 락을 걸지 않고, 파티션 단위로 삭제할 수 있으며, `RANGE` 타입의 파티션에서는 가장 오래된 파티션 순으로 삭제할 수 있습니다.

### 4. **고민해 볼 점 (Trade-offs)**
- `HASH` 파티셔닝은 특정한 기준이 정해지지 않은 파티셔닝입니다. 따라서 지정된 기준(월/년도 단위)의 분석을 위한 쿼리에 사용할 경우, 모든 파티션을 탐색해야 하는 문제가 발생합니다.
